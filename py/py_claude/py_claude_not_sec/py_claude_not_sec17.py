import ast
import networkx as nx
from typing import Dict, List, Set
from dataclasses import dataclass
from pathlib import Path

@dataclass
class FunctionInfo:
    """Informationen über eine analysierte Funktion"""
    name: str
    parameters: List[str]
    return_type: str
    dependencies: Set[str]
    complexity: int

class CodeAnalyzer:
    """Analysiert Python-Code mittels AST"""
    
    def __init__(self, source_code: str):
        self.tree = ast.parse(source_code)
        self.functions: Dict[str, FunctionInfo] = {}
        self.dependency_graph = nx.DiGraph()
        
    def analyze(self):
        """Führt die vollständige Codeanalyse durch"""
        self._extract_functions()
        self._build_dependency_graph()
        
    def _extract_functions(self):
        """Extrahiert Funktionsinformationen aus dem AST"""
        for node in ast.walk(self.tree):
            if isinstance(node, ast.FunctionDef):
                # Parameter extrahieren
                params = [arg.arg for arg in node.args.args]
                
                # Rückgabetyp aus Annotation extrahieren (falls vorhanden)
                return_type = "Any"
                if node.returns:
                    return_type = ast.unparse(node.returns)
                
                # Abhängigkeiten finden
                deps = set()
                for child in ast.walk(node):
                    if isinstance(child, ast.Call):
                        if isinstance(child.func, ast.Name):
                            deps.add(child.func.id)
                
                # Zyklomatische Komplexität berechnen
                complexity = self._calculate_complexity(node)
                
                self.functions[node.name] = FunctionInfo(
                    name=node.name,
                    parameters=params,
                    return_type=return_type,
                    dependencies=deps,
                    complexity=complexity
                )
    
    def _calculate_complexity(self, node: ast.AST) -> int:
        """Berechnet die zyklomatische Komplexität einer Funktion"""
        complexity = 1  # Basiskomplexität
        
        for child in ast.walk(node):
            if isinstance(child, (ast.If, ast.While, ast.For, ast.Try,
                               ast.ExceptHandler, ast.Assert,
                               ast.BoolOp)):
                complexity += 1
                
        return complexity
    
    def _build_dependency_graph(self):
        """Erstellt einen Abhängigkeitsgraphen der Funktionen"""
        for func_name, func_info in self.functions.items():
            self.dependency_graph.add_node(func_name)
            for dep in func_info.dependencies:
                if dep in self.functions:
                    self.dependency_graph.add_edge(func_name, dep)

class TestGenerator:
    """Generiert Testfälle basierend auf der Codeanalyse"""
    
    def __init__(self, analyzer: CodeAnalyzer):
        self.analyzer = analyzer
        
    def generate_tests(self) -> str:
        """Generiert Testfälle für alle analysierten Funktionen"""
        test_code = []
        
        # Header
        test_code.append("import unittest")
        test_code.append("from typing import Any")
        test_code.append("from your_module import *  # Module importieren")
        test_code.append("\n")
        
        # Testklasse
        test_code.append("class AutoGeneratedTests(unittest.TestCase):")
        
        # Funktionen nach Abhängigkeiten sortieren
        sorted_functions = list(nx.topological_sort(self.analyzer.dependency_graph))
        
        # Testmethoden für jede Funktion generieren
        for func_name in sorted_functions:
            func_info = self.analyzer.functions[func_name]
            test_code.extend(self._generate_function_tests(func_info))
        
        # Main-Block
        test_code.append("\n")
        test_code.append("if __name__ == '__main__':")
        test_code.append("    unittest.main()")
        
        return "\n".join("    " + line if line else line 
                        for line in test_code)
    
    def _generate_function_tests(self, func_info: FunctionInfo) -> List[str]:
        """Generiert Testfälle für eine einzelne Funktion"""
        test_cases = []
        
        # Basis-Testfall
        test_cases.extend([
            f"\ndef test_{func_info.name}_basic(self):",
            f"    # Test basic functionality of {func_info.name}",
            "    try:",
            f"        result = {func_info.name}({', '.join('None' for _ in func_info.parameters)})",
            "        self.assertIsNotNone(result)",
            "    except Exception as e:",
            "        self.fail(f'Function raised {e}')",
        ])
        
        # Komplexitäts-basierte Tests
        if func_info.complexity > 1:
            test_cases.extend([
                f"\ndef test_{func_info.name}_edge_cases(self):",
                f"    # Test edge cases for {func_info.name} (complexity: {func_info.complexity})",
                "    # TODO: Add specific edge cases based on complexity",
                "    pass"
            ])
        
        # Parameter-Typ-Tests
        if func_info.parameters:
            test_cases.extend([
                f"\ndef test_{func_info.name}_parameter_types(self):",
                f"    # Test parameter type handling for {func_info.name}",
                "    with self.assertRaises(TypeError):",
                f"        {func_info.name}({', '.join('object()' for _ in func_info.parameters)})"
            ])
        
        return test_cases

class TestingSystem:
    """Hauptklasse des Testgenerierungssystems"""
    
    @staticmethod
    def generate_tests_for_file(file_path: Path) -> str:
        """Generiert Tests für eine Python-Datei"""
        # Code einlesen
        source_code = file_path.read_text()
        
        # Code analysieren
        analyzer = CodeAnalyzer(source_code)
        analyzer.analyze()
        
        # Tests generieren
        generator = TestGenerator(analyzer)
        return generator.generate_tests()

# Beispiel zur Verwendung:
if __name__ == "__main__":
    # Beispiel-Datei verarbeiten
    file_path = Path("your_module.py")
    tests = TestingSystem.generate_tests_for_file(file_path)
    
    # Tests in Datei schreiben
    output_path = Path("test_generated.py")
    output_path.write_text(tests)